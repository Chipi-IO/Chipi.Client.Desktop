import { chipiAuth } from "../../../lib/chipi";
import Logger from "../../../lib/logger";
import rendering from "./rendering";
import alias from "./alias";
import search from "./search";
import magicFilterProvider from "./magicFilterProvider";
import { IChipiFoundItem, ISearchResultItem } from "@app/models/interfaces";

var logger = new Logger("plugins.chipi");
var userDataProvider;

const order = 1;

// Settings plugin name
const NAME = "Chipi Search";

// Phrases that used to find settings plugins
const KEYWORDS = [NAME];

// Used to cope the racing condition of the on fly search requests due to the ealier requests may come after the latest requests.
let currentSearchId = 0;

/**
 * Process potential alias command
 * @param {String} term
 * @param {Function} display function to display and output generated by the alias command
 * @param {Function} onResultItemUpdated function to pass the output item updated event back to the main system
 */
const _processAliasAsync = async (term, display, onResultItemUpdated) => {
  return alias.processAliasAsync(term, display, onResultItemUpdated).then(response => {
    if (!response) return;

    // We only care about the first response from all alias
    return response.newTerm;
  });
};

/**
 * Search term against CHIPI search api
 * @param {Object} options
 */
const _searchTermAsync = async ({
  term,
  filters,
  display,
  displaySuggestion,
  displayFilter,
  actions,
  dispatch
}) => {
  const authState = chipiAuth.getAuthState();

  // Complete search for the term against chipi search api
  if (authState && authState.isAuthenticated && term.length > 2) {
    currentSearchId = currentSearchId >= 2000 ? 0 : currentSearchId + 1; // Avoid the current search id growing too big :p

    const flyingSearchId = currentSearchId;

    const searchPromise = search.getSearchResults({
      term,
      filters
    });

    //return Promise.all([suggestionPromise, searchPromise])
    return searchPromise
      .then(searchResponse => {
        if (flyingSearchId !== currentSearchId) {
          return;
        }

        return rendering.prepareChipiSearchResultAsync({
          searchResponsePayload: searchResponse.payload,
          searchTerm: term,
          clientActions: actions
        });
      })
      .then(results => {
        if (results) {
          results.filter(Boolean).forEach(result => {
            result.order = order;
          });

          display(results);
        }
      })
      .catch(err => {
        logger.error("Failed to search through Chipi", { err });
      });
  }

  return Promise.resolve();
};

const searchThreadAsync = async (chipiFoundItem: IChipiFoundItem): Promise<ISearchResultItem[]> => {
  if (!chipiFoundItem || !chipiFoundItem.foundItem) {
    return;
  }

  if (!chipiFoundItem.foundItem._source.fromThreadId) {
    return await rendering.toSearchResultFormatAync({
      foundItem: chipiFoundItem.foundItem,
      additionalData: chipiFoundItem.additionalData,
      searchTerm: chipiFoundItem.searchTerm,
      clientActions: chipiFoundItem.clientActions
    });
  }

  const threadSearchingResponse = await search.getThreadResultsAsync(
    chipiFoundItem.foundItem._source.fromThreadId
  );

  if (!threadSearchingResponse || !threadSearchingResponse.payload) {
    return;
  }

  return await rendering.prepareChipiSearchResultAsync({
    searchResponsePayload: threadSearchingResponse.payload,
    searchTerm: chipiFoundItem.searchTerm,
    clientActions: chipiFoundItem.clientActions
  });
};

/**
 * Provide magic filter suggestions
 * @param {Object} options
 */
const chipiSearchMagicFilterSuggestion = ({
  term,
  displayMagicFilterSuggestion,
  cursorPosition
}) => {
  return magicFilterProvider
    .findSuggestionByTerm(term, cursorPosition)
    .then(magicFilterSuggestion => {
      displayMagicFilterSuggestion(magicFilterSuggestion);
    });
};

/**
 * Main function for CHIPI search plugin
 * @param {Object} options
 */
const chipiSearchPlugin = ({
  term,
  filters,
  display,
  displaySuggestion,
  displayFilter,
  config,
  actions,
  dispatch
}) => {
  return _processAliasAsync(term, display, actions.onResultItemUpdated).then(
    aliasReturnedNewTerm => {
      if (aliasReturnedNewTerm) {
        term = aliasReturnedNewTerm;
      }

      return _searchTermAsync({
        term,
        filters,
        display,
        displaySuggestion,
        displayFilter,
        actions,
        dispatch
      });
    }
  );
};

export default {
  name: NAME,
  fn: chipiSearchPlugin,
  magicFilterSuggestion: chipiSearchMagicFilterSuggestion,
  supportEmptyTerm: true,
  supportFilters: true,
  searchThreadAsync
};
